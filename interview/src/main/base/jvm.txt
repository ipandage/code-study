jvm 是如何分配和回收内存
http://www.cnblogs.com/magialmoon/p/jvm-memory-and-gc.html

jvm问题分析

堆内存转储工具
Heap Dump 是一个二进制文件，保存了jvm某一时刻堆中对象的内存使用情况，可以使用MAT，IBM Heap Analyzer这类工具分析
MAT设计的初衷是帮助用户找出内存泄漏的原因

线程转储工具
jstack
当服务器难以接受请求，应用程序响应极慢或者不响应，观察JVM“僵死”现象时，应当考虑JVM是否遇到资源瓶颈了。
操作步骤
1.获取线程转储信息
2.排除死锁
3.定位资源瓶颈
locked 确认大批请求在临界区 等待数据库链接 ，有时需要确认是否等待相同资源，数据库连接池资源遇到了瓶颈
4.判断引起资源瓶颈的程序来源，对症下药

值得关注的线程状态
死锁，Deadlock（重点关注）
执行中，Runnable
等待资源，Waiting on condition（重点关注）
等待获取监视器，Waiting on monitor entry（重点关注）
暂停，Suspended
对象等待中，Object.wait() 或 TIMED_WAITING
阻塞，Blocked（重点关注）
停止，Parked

类加载过程 http://blog.csdn.net/u011955252/article/details/49643503
加载 连接（验证 准备 解析） 初始化
加载 class二进制文件加载到内存
连接-验证 验证class文件格式是否正确，语法是否正确，字节码是否正确，二进制内容是否兼容
连接-准备 为类的静态变量分配空间，并赋予默认初始值
连接-解析 将class文件中的符号引用变为直接引用
初始化，为类的静态变量赋予正确的初始值，只有在类首次使用的时候才会初始化

为什么新生代内存需要有两个Survivor区? http://blog.csdn.net/antony9118/article/details/51425581
Survivor 存在的意义就是减少被送到老年代的对象，进而减少Full GC的发生，
只有经历15次Minor GC还能在新生代存活的对象，才会被送到老年代

堆大小 = 新生代（1/3） + 老年代（2/3）
Eden : from : to = 8 : 1 : 1
GC分两种: 老年代使用标记清除算法，新生代采用复制算法
对象送入老年代的年龄 默认15 ，可以通过参数 -XX:MaxTenuringThreshold 设定

触发Full GC的集中情况
年轻代回收内存被称为 Minor GC， 对老年代的GC成为Major GC，Full GC是对整个堆来说的
Major GC的速度一般会比Minor GC慢10倍以上

1.System.gc 方法调用
2.老年代空间不足
3.永生区空间不足
4.CMS GC时出现promotion failed和concurrent mode failure
5.统计得到Monor GC晋升到老年代的大小大于老年代的 剩余空间
6.堆中分配很大的对象（所谓大对象是指需要大量连续内存空间的java对象，例如很长的数组）

内存屏障 内存栅栏，是一类同步屏障指令，是cpu或者编译器在对内存随机访问的操作中的一个同步点，
使得此点之前的读写操作都执行后开开始执行此点之后的操作，
内存屏障之前的所有写操作都要写入内存，内存屏障之后的读操作都可以获得同步屏障之前写操作的结果，
因此 对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障

指令重排序 http://blog.csdn.net/beiyetengqing/article/details/49580559
为何要指令重排序

重排序的背景
现代CPU主频越来越高，与cache的交互次数也越来越多，当cpu的运算速度远远超过访问cache时，会产生
cache wait 过多的cache wait 会造成性能瓶颈

编译器或者运行时环境为了优化程序性能而采取的对指令进行重排序执行的一种手段
所有的语句顺序都可以进行重排序？
数据依赖性





