事物传播行为介绍:
@Transactional(propagation=Propagation.REQUIRED)
如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)
@Transactional(propagation=Propagation.NOT_SUPPORTED)
容器不为这个方法开启事务
@Transactional(propagation=Propagation.REQUIRES_NEW)
不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务
@Transactional(propagation=Propagation.MANDATORY)
必须在一个已有的事务中执行,否则抛出异常
@Transactional(propagation=Propagation.NEVER)
必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)
@Transactional(propagation=Propagation.SUPPORTS)
如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行

事物超时设置:
@Transactional(timeout=30) //默认是30秒

事务隔离级别:
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
读取未提交数据(会出现脏读, 不可重复读) 基本不使用
保证了读取过程中不会读取到非法数据。

@Transactional(isolation = Isolation.READ_COMMITTED)
读取已提交数据(会出现不可重复读和幻读)
大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”。该级别适用于大多数系统。

@Transactional(isolation = Isolation.REPEATABLE_READ)
可重复读(会出现幻读)
保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但是带来了更多的性能损失。

@Transactional(isolation = Isolation.SERIALIZABLE)
串行化
最严格的级别，事务串行执行，资源消耗最大；

　　                    Dirty reads　　　　 non-repeatable reads　　　　　 phantom reads
Serializable　　　　　　　不会　　　　　　　　　 不会　　　　　　　　　　　　　 不会
REPEATABLE READ　　　　　 不会　　　　　　　　　 不会　　　　　　　　　　　　　  会
READ COMMITTED　　　　　  不会　　　　　　　　　  会　　　　　　　　　　　　　　 会
Read Uncommitted　　　　　 会　　　　　　　　　　 会　　　　　　　　　　　　　　 会